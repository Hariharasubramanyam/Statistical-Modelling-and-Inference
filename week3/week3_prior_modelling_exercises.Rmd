---
title: "Statistical Modelling and Inference: Week 3 Prior Modelling"
output: pdf_document
---

### Questions from Prior Modelling

#### 1. Continuation of your work on smooth function estimation with the data in curve_data.txt. Extend your program to also learn q from the data. Work with the Normal-Gamma prior with specification.

**Produce a figure that includes posterior draws of the linear predictor for this model**

```{r, echo = FALSE}
library(metRology)
library(splines)
library(MASS)

phix <- function(x, M, basis_type) {
  phi <- rep(0, M)
  if (basis_type == "poly") {
    for (i in 1:(M)) {
      phi[i] <- x**i
    }
  }
  if (basis_type == "Gauss") {
    phi[1] <- 1
    for (i in 2:(M+1)) {
      phi[i] <- exp(-((x-i/(M))**2)/0.1)
    }
    
  }
  phi
}

post.params <- function(data, M, basis_type, delta, a0, b0) {
  N = length(data$x)
  phi = phix(data$x[1], M, basis_type)
  for (i in 2:length(data$x)) {
    phi_ <- phix(data$x[i], M, basis_type)
    phi = rbind(phi, phi_)  
  }

  data.precision <- 1 / (sd(data$t)^2)

  # Estimate parameters using MLE
  mle <- lm(data$t ~ phi)
  mle.params <- mle$coefficients
  mle.var <- sd(mle$fitted.values)^2
  mle.precision <- 1 / mle.var
  mle.fitted.values <- mle$fitted.values
  
  # Estimate parameters using Bayes - claiming to know q
  regularization.D <- delta * diag(ncol(phi))
  bayes.Q <- regularization.D + q * (t(phi) %*% phi)
  bayes.params <- solve(bayes.Q) %*% (q * t(phi) %*% data$t)
  bayes.fitted.values <- phi %*% bayes.params
  bayes.var <- sd(bayes.fitted.values) ^ 2
  bayes.precision <- 1 / bayes.var

  # Estimate parameters using Bayes and sNG - setting 'g' to 1
  g <- bayes.precision
  bayes.sng.Dprime <- 1/g * (regularization.D + g * (t(phi) %*% phi))
  bayes.sng.aprime <- a0 + N/2
  bayes.sng.K.identity <- diag(nrow = N, ncol = N)
  bayes.sng.K <- g * phi %*% solve(regularization.D + g * t(phi) %*% phi) %*% t(phi)
  bayes.sng.bprime <- b0 + (1/2) * t(data$t) %*% (bayes.sng.K.identity - bayes.sng.K) %*% data$t
  bayes.sng.fitted.values <- bayes.sng.K %*% data$t
  
  return(list(
    mle.fitted.values = mle.fitted.values,
    bayes.fitted.values = bayes.fitted.values,
    bayes.sng.fitted.values = bayes.sng.fitted.values,
    bayes.params = bayes.params,
    bayes.sng.bprime = bayes.sng.bprime,
    bayes.sng.aprime = bayes.sng.aprime,
    bayes.sng.Dprime = bayes.sng.Dprime))
}

M <- 6
delta <- 1
q = (1/0.1)^2
a0 <- -1/2
b0 <- 0
basis_type <- 'Gauss'
data <- read.csv('curve_data.txt', sep = ' ')

result <- post.params(data, M, basis_type, delta, a0, b0)
plot(c(0,1), c(-1,1), type="n")
points(data$x, data$t, col = 'red')
lines(predict(splines::interpSpline(data$x, result$mle.fitted.values)), col = 'green')
lines(predict(splines::interpSpline(data$x, result$bayes.fitted.values)), col = 'blue')
lines(predict(splines::interpSpline(data$x, result$bayes.sng.fitted.values)), col = 'orange')
legend(0, 0, legend = c("mle", "bayes", "bayes sng"), lty=c(1,1), lwd=c(2.5,2.5),col=c("green", "blue", "orange"))

test.x <- seq(0,1,1/10)

prediction.bayes <- function(data, x, M, basis_type, delta, a, b) {
  bayes.post.params <- post.params(data, M, basis_type, delta, a0, b0)

  test.y <- matrix(nrow = length(test.x), ncol = 2)
  dimnames(test.y)[[2]] <- list("test.x", "test.y")
  # create phi(testx) by sending all the test x to phix
  phi.test.x <- matrix(nrow = length(test.x), ncol = M+1)
  for (n in 1:length(test.x)) {
    test.y[n,"test.x"] <- test.x[n]
    phi.test.x[n,] <- c(phix(test.x[n], M, basis_type))
  }

  for (n in 1:nrow(phi.test.x)) {
    xphix <- phi.test.x[n,]

    F <- solve(1 + t(xphix) %*% solve(bayes.post.params$bayes.sng.Dprime) %*% xphix)
    # FIXME: Have to take the mean of this distribution for the draws from the linear predictor to not look crazy, doesn't seem right
    test.y[n,"test.y"] <- mean(rt.scaled(
      n = 100,
      mean = t(xphix) %*% bayes.post.params$bayes.params,
      sd = 1/sqrt(bayes.post.params$bayes.sng.aprime/bayes.post.params$bayes.sng.bprime * F),
      df = bayes.post.params$bayes.sng.aprime * 2))
  }

  return(test.y)
}

plot(data)

for (n in 1:100) {
  test.y <- prediction.bayes(data, test.x, M, basis_type, delta, a, b)
  lines(predict(splines::interpSpline(test.y[,'test.x'], test.y[,'test.y'])), col = 'pink') 
}
points(data)

delta_seq <- seq(0,10,1)
plot(data)
for (n in 1:length(delta_seq)) {
  this.delta <- delta_seq[n]
  test.y <- prediction.bayes(data, test.x, M, basis_type, this.delta, a, b)
  lines(predict(splines::interpSpline(test.y[,'test.x'], test.y[,'test.y'])), col = 'pink') 
}

delta_seq <- seq(0,1,0.05)
plot(data)
for (n in 1:length(delta_seq)) {
  this.delta <- delta_seq[n]
  test.y <- prediction.bayes(data, test.x, M, basis_type, this.delta, a, b)
  lines(predict(splines::interpSpline(test.y[,'test.x'], test.y[,'test.y'])), col = 'pink') 
}
```


#### 2.Priors that penalize the L1 norm of the mean of a Gaussian and MAP estimation

**2.1 Suppose for simplicity that a > 0 (a < 0 can be handled in the same way), assume also that $\lambda > 0$ and consider the function $f(\mu) = (\mu - a) 2 + \lambda | \mu |$. Show that $\mu$ is minimised at $(a - \lambda / 2)^{+}$ where $x^{+}$ denotes the positive part of x.**

&nbsp;

QUESTION: SHOULDN'T THIS BE THE POSITIVE PART OF $\mu$?

&nbsp;

To solve for the minimum of $\mu$, we take the derivative and set it to zero.

$$f(\mu) = \mu^{2} - 2a\mu - a^{2} - \lambda |\mu|$$

(take the derivative and set to 0)

$$\frac{df(\mu)}{d\mu} = 2\mu - 2a + \lambda = 0$$

(add $2a - \lambda$ to both sides)

$$2\mu = 2a - \lambda$$

(divide both sides by 2)

$$\mu = a - \lambda / 2$$

Q.E.D.

**2.2**

To estimate $w_{MAP}$, we want to maximize the joint probability $p(t, X, w, q)$. To maximize the joint probability, we must maximize the conditional probabilities of the prior and the log of the likelihood estimator of the probability for t. In so doing, we will calculate the MAP (maximum posterior)

The prior for w is given by the laplace distribution:

$$p(w) -> exp{(- \delta / 2) \sum_{i} |w_{i}| }$$

$t$ is normally distributed, and the log likelihood of it's conditional probabilty is given by:

$$ln p(t | x, w, q) = -q/2 \sum_{n=1}^{N} { y(x, w) - t_{n} } + \frac{N}{2}ln (q) - \frac{N}{2}ln(2\pi)$$

To maximize the likelihood of t with respect to w, we take the partial derivative with respect to w and set it to 0. The two right-most terms are omitted in this operation because they do not depend on w.

> Also, we note that scaling the log likelihood by a positive constant coefficient does not alter the location of the maximum with respect to w, and so we can replace the coefficient $\beta/2$ with 1/2. Finally, instead of maximizing the log likelihood, we can equivalently minimize the negative log likelihood. We therefore see that maximizing likelihood is equivalent, so far as determining w is concerned, to minimizing the sum-of-squares error function defined by (1.2). (page 47 of Bishop)

To maximize the prior (p(w) ~ the laplace distribution), we similarly maximize the log likelihood of the prior, so we want to maximize

$$ln p(w) = \frac{- \delta}{2} \sum_{i} |w_{i}|$$

To maximize the prior, we take it's derivative wrt w and set it to 0:

$$\frac{d ln p(w)}{dw} = - \delta i = 0$$

So the maximization of the prior occurs when $\delta$ is set equal to 0 and we can maximize $w_{MAP}$ simply by minimizing the sum-of-squares error function.

$$\frac{q}{2}\sum_{n = 1}^{N} { y(x_{n}, w) - t_{n} }^2$$

&nbsp;

