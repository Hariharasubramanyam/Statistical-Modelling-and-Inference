---
title: "Statistical Modelling and Inference: Week 3 Prior Modelling"
output: pdf_document
---

### Questions from Prior Modelling

#### 1. Continuation of your work on smooth function estimation with the data in curve_data.txt. Extend your program to also learn q from the data. Work with the Normal-Gamma prior with specification.

**Produce a figure that includes posterior draws of the linear predictor for this model**

```{r, echo = FALSE}

library(splines)
library(MASS)

M <- 9
delta <- 0.5
a0 <- -1/2
b0 <- 0
basis_type <- 'Gauss'
test.x <- seq(0,1,1/1000)

data <- read.csv('curve_data.txt', sep = ' ')

phix <- function(x, M, option) {
  phi <- rep(0, M)
  if (option == "poly") {
    for (i in 1:(M)) {
      phi[i] <- x**i
    }
  }
  if (option == "Gauss") {
    for (i in 1:(M)) {
      phi[i] <- exp(-((x-i/(M))**2)/0.1)
    }
    
  }
  phi
}

gamma.a <- function(a0, N) { a0 + N/2 }
# b according to Bishop
gamma.b <- function(b0, N, var_mle) { b0 + (N/2) * var_mle }
# b according to Omiros (SLIDE 13 OF Prior Modelling)
# but we don't know K?? K:=g(D+gΦTΦ)−1ΦT
# gamma.b <- function(b0, t, K) { b0 + ((1/2) * t(t) * (diag(length(t)) - K) * t) }

post.params <- function(data, M, option, delta, a0, b0) {
  phi = phix(data$x[1],M, option)
  for (i in 2:length(data$x)) {
    phi_ <- phix(data$x[i], M, option)
    phi = rbind(phi, phi_)  
  }
  phi <- cbind(rep(1,M+1), phi)

  mle <- lm.fit(phi, data$t)
  var_mle <- var(mle$fitted.values)
  posterior.a <- gamma.a(a0, length(data$x))
  posterior.b <- gamma.b(b0, length(data$x), var_mle)
  # expected value of the gamma dist
  posterior.g.expected_value <- posterior.a / posterior.b
  
  g <- posterior.g.expected_value
  D <- diag(ncol(phi))
  # (slide 12 or 13 - are equivalent)
  Q <- ((g^(-1) * (delta * D)) + t(phi) %*% phi)
  # (slide 12) NOT sure why this doesn't line up with slide 13
  w <- solve(Q) %*% (t(phi) %*% data$t)
  t <- phi%*%w

  # FIXME: Return a key-value
  return(list(Q, w, t, posterior.a, posterior.b))
}

answer <- post.params(data, 9, "Gauss", delta, a0, b0)
linear_predictor <- answer[[3]]
posterior.a <- answer[[4]]
posterior.b <- answer[[5]]

plot(data, col ='red')

lines(predict(splines::interpSpline(data$x, linear_predictor)), col ='blue')

pediction.bayes <- function(data, x, M, basis_type, delta) {
  input_data_params <- post.params(data, M, basis_type, delta, a0, b0)
  Qbayes <- input_data_params[[1]]
  wbayes <- input_data_params[[2]]
  
  # create phi(testx) by sending all the test x to phix
  phi.test.x <- matrix(nrow = length(test.x), ncol = M+1)
  for (n in 1:length(test.x)) {
    phi.test.x[n,] <- c(1, phix(test.x[n], M, basis_type))
  }
  
  test.y <- matrix(nrow = length(test.x), ncol = 2)
  dimnames(test.y)[[2]] <- list("test.x", "test.y")
  for (n in 1:nrow(phi.test.x)) {
    test.y[n,"test.x"] <- test.x[n]
    test.y[n,"test.y"] <- t(phi.test.x[n,]) %*% wbayes
  }

  Qbayesinv <- solve(Qbayes)
# WAS THIS
#   Qbayesinv <- solve(Qbayes)
#   covmatrix <- phi.test.x %*% Qbayesinv %*% t(phi.test.x) + 1/q
  # ACCORDING TO SLIDE 13?
  f <- (1 + phi.test.x %*% Qbayesinv %*% t(phi.test.x))
  covmatrix <- (posterior.a/posterior.b) * f

  return(list(test.y, covmatrix, Qbayes, wbayes, covmatrix))
}

result <- pediction.bayes(data, test.x, M, basis_type, delta)
test.ys <- result[1][[1]]
sds <- sqrt(diag(result[2][[1]]))
Qbayes <- result[3][[1]]
wbayes <- result[4][[1]]

plot(data$x, data$t, ylim = range(-1.5:1.5), col = 'red')
lines(x = test.ys[,"test.x"], y = test.ys[,"test.y"])
lines(x = test.ys[,"test.x"], y = (test.ys[,"test.y"] + sds), col = 'grey')
lines(x = test.ys[,"test.x"], y = (test.ys[,"test.y"] - sds), col = 'grey')

plot(data, col = 'red', ylim = range(-1.5:1.5))

nsims <- 100
mins <- rep(0, nsims)
maxs <- rep(0, nsims)

for (sim in 1:nsims) {
  # generate random draws of N(w,cov) and plot random xs evaluated for each
  # Procedure: 
  #  1) generate a random draw of N(w, cov) -> this becomes a new (random) w (from the same distribution as wbayes)
  wbayesrand <- mvrnorm(n = 1, wbayes, Sigma = solve(Qbayes))
  #  2) generate 100 random xs to calculate phix(x...)
  xs <- runif(100)
  #  3) generate their y's as t(phix(xs)) %*% wbayesrand
  ys <- rep(0, length(xs))
  for (n in 1:length(xs)) {
    testphi <- c(1, phix(xs[n], M, basis_type))
    ys[n] <- t(testphi) %*% wbayesrand
  }
  mins[sim] <- min(ys)
  maxs[sim] <- max(ys)
  lines(predict(splines::interpSpline(xs, ys)), col ='grey')
}
points(data, col ='red')

```


#### 2.Priors that penalize the L1 norm of the mean of a Gaussian and MAP estimation

**2.1 Suppose for simplicity that a > 0 (a < 0 can be handled in the same way), assume also that $\lambda > 0$ and consider the function $f(\mu) = (\mu - a) 2 + \lambda | \mu |$. Show that $\mu$ is minimised at $(a - \lambda / 2)^{+}$ where $x^{+}$ denotes the positive part of x.**

&nbsp;

QUESTION: SHOULDN'T THIS BE THE POSITIVE PART OF $\mu$?

&nbsp;

To solve for the minimum of $\mu$, we take the derivative and set it to zero.

$$f(\mu) = \mu^{2} - 2a\mu - a^{2} - \lambda |\mu|$$

(take the derivative and set to 0)

$$\frac{df(\mu)}{d\mu} = 2\mu - 2a + \lambda = 0$$

(add $2a - \lambda$ to both sides)

$$2\mu = 2a - \lambda$$

(divide both sides by 2)

$$\mu = a - \lambda / 2$$

Q.E.D.

**2.2**

To estimate $w_{MAP}$, we want to maximize the joint probability $p(t, X, w, q)$. To maximize the joint probability, we must maximize the conditional probabilities of the prior and the log of the likelihood estimator of the probability for t. In so doing, we will calculate the MAP (maximum posterior)

The prior for w is given by the laplace distribution:

$$p(w) -> exp{(- \delta / 2) \sum_{i} |w_{i}| }$$

$t$ is normally distributed, and the log likelihood of it's conditional probabilty is given by:

$$ln p(t | x, w, q) = -q/2 \sum_{n=1}^{N} { y(x, w) - t_{n} } + \frac{N}{2}ln (q) - \frac{N}{2}ln(2\pi)$$

To maximize the likelihood of t with respect to w, we take the partial derivative with respect to w and set it to 0. The two right-most terms are omitted in this operation because they do not depend on w.

> Also, we note that scaling the log likelihood by a positive constant coefficient does not alter the location of the maximum with respect to w, and so we can replace the coefficient $\beta/2$ with 1/2. Finally, instead of maximizing the log likelihood, we can equivalently minimize the negative log likelihood. We therefore see that maximizing likelihood is equivalent, so far as determining w is concerned, to minimizing the sum-of-squares error function defined by (1.2). (page 47 of Bishop)

To maximize the prior (p(w) ~ the laplace distribution), we similarly maximize the log likelihood of the prior, so we want to maximize

$$ln p(w) = \frac{- \delta}{2} \sum_{i} |w_{i}|$$

To maximize the prior, we take it's derivative wrt w and set it to 0:

$$\frac{d ln p(w)}{dw} = - \delta i = 0$$

So the maximization of the prior occurs when $\delta$ is set equal to 0 and we can maximize $w_{MAP}$ simply by minimizing the sum-of-squares error function.

$$\frac{q}{2}\sum_{n = 1}^{N} { y(x_{n}, w) - t_{n} }^2$$

*QUESTION: WHAT IS CLOSED FORM? IS THIS SUFFICIENT?*
&nbsp;
*QUESTION: ARE $\beta$ AND $q$ THE SAME? OR IS $q$ $\beta^{-1}$ ?*

